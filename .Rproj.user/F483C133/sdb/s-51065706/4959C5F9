{
    "collab_server" : "",
    "contents" : "\nmap_locations <- function(dta, outpath,variable=NULL,title)\n{\n  lonlat <- dta[,c(\"Longitude\", \"Latitude\")]\n  full.spdf <- SpatialPointsDataFrame(coords = lonlat, data = dta,\n                                          proj4string = CRS(\"+proj=longlat +datum=WGS84 +ellps=WGS84\"))\n  land.mask <- readOGR(\"data/countries.geojson\", \"OGRGeoJSON\")\n  p <- spplot(full.spdf, zcol=variable, colorkey=FALSE, cex=0.25,\n              cuts=c(0,1),\n              col.regions=c(colors()[c(81)]),\n              xlim=c(-180,180),\n              ylim=c(-60,90),\n              key=list(lines=TRUE, col=\"transparent\"),\n              pch=5,\n              main=list(label=title,cex=0.5),\n              sp.layout = list(list(land.mask, fill=\"grey\", first=TRUE)))\n  graphics.off()\n  print(dev.list())\n  png(outpath,\n      width = 6, \n      height = 4, \n      units = 'in', \n      res = 300)\n  print(p)\n  dev.off()\n}\n\n\nplot.tree.forestCover <- function(final.tree, m.title, outfile)\n{\n  print.tree <- final.tree\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"accessibility_map.na.mean\"] <- \"Urb Dist\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"total_disbursements\"] <- \"Disbursements\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_max_precip\"] <- \"Max Precip\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_min_precip\"] <- \"Min Precip\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"treecover2000.na.mean\"] <- \"Treecover\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"srtm_elevation_500m.na.mean\"] <- \"Elevation\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"dist_to_roads.na.mean\"] <- \"Road Dist\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"wdpa_5km.na.sum\"] <- \"Protected\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"dist_to_all_rivers.na.mean\"] <- \"River Dist\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_average_NTL\"] <- \"Nighttime Lights\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_average_precip\"] <- \"Avg Precip\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_max_LTDR\"] <- \"Max NDVI\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_max_temp\"] <- \"Max Temp\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_average_temp\"] <- \"Avg Temp\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"gpw_v3_density.2000.mean\"] <- \"Pop Density\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"post_implementation_time\"] <- \"Years Since Proj. Imp.\"\n  \n  png(outfile, width = 1280, height = 720)\n  rpart.plot(print.tree, extra=1, branch=1, type=4, tweak=1, clip.right.labs=FALSE,\n             box.col=c(\"palegreen3\", \"pink\")[findInterval(print.tree $frame$yval, v = c(-1,0))],\n             faclen=0,\n             varlen=0,fallen.leaves=FALSE\n  )\n  title(m.title)\n  dev.off()\n}\n\nplot.tree.NDVI <- function(final.tree, m.title, outfile)\n{\n  print.tree <- final.tree\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"accessibility_map.na.mean\"] <- \"Urb Dist\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"total_disbursements\"] <- \"Disbursements\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_max_precip\"] <- \"Max Precip\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_min_precip\"] <- \"Min Precip\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"treecover2000.na.mean\"] <- \"Treecover\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"srtm_elevation_500m.na.mean\"] <- \"Elevation\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"dist_to_roads.na.mean\"] <- \"Road Dist\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"wdpa_5km.na.sum\"] <- \"Protected\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"dist_to_all_rivers.na.mean\"] <- \"River Dist\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_average_NTL\"] <- \"Nighttime Lights\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_average_precip\"] <- \"Avg Precip\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_max_LTDR\"] <- \"Max NDVI\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_max_temp\"] <- \"Max Temp\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"pre_average_temp\"] <- \"Avg Temp\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"gpw_v3_density.2000.mean\"] <- \"Pop Density\"\n  levels(print.tree $frame$var)[levels(print.tree $frame$var)==\"post_implementation_time\"] <- \"Years Since Proj. Imp.\"\n  \n  png(outfile, width = 1920, height = 1280)\n  rpart.plot(print.tree , fallen.leaves=FALSE, cex=1.0, extra=1, branch=1, type=4, tweak=1.4, clip.right.labs=FALSE,\n             box.col=c(\"pink\", \"palegreen3\")[findInterval(print.tree $frame$yval, v = c(-10000,0))],\n             faclen=0,\n             varlen=0\n  )\n  title(m.title)\n  dev.off()\n}\n\n\n# Multiple plot function\n#\n# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n# - cols:   Number of columns in layout\n# - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n#\n# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),\n# then plot 1 will go in the upper left, 2 will go in the upper right, and\n# 3 will go all the way across the bottom.\n#\nmultiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n  library(grid)\n  \n  # Make a list from the ... arguments and plotlist\n  plots <- c(list(...), plotlist)\n  \n  numPlots = length(plots)\n  \n  # If layout is NULL, then use 'cols' to determine layout\n  if (is.null(layout)) {\n    # Make the panel\n    # ncol: Number of columns of plots\n    # nrow: Number of rows needed, calculated from # of cols\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                     ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n  \n  if (numPlots==1) {\n    print(plots[[1]])\n    \n  } else {\n    # Set up the page\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n    \n    # Make each plot, in the correct location\n    for (i in 1:numPlots) {\n      # Get the i,j matrix positions of the regions that contain this subplot\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n      \n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}\n\n\n",
    "created" : 1480703961166.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "849583982",
    "id" : "4959C5F9",
    "lastKnownWriteTime" : 1479841151,
    "last_content_update" : 1479841151,
    "path" : "~/Desktop/Github/GEF_MFA/Visualization/viz.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}